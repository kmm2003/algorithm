let main=()=>{
    let [N,M,K]=prompt('').split(' ');
    K=parseInt(K); // K를 int형으로 강제형 변환(안해주면 15,16줄에서 오류 발생)
    let index=[];
    let result=0;
    let count=0; // 연산과정에서 최대값 사용 횟수 카운트 변수 선언
    for(i=0;i<N;i++){
        let tmp=prompt(`${i+1}번째 숫자`);
        index.push(tmp);
    }
    index=index.sort((a,b)=>{
        return b-a
    })
    index=[index[0],index[1]];
    count+=Math.floor(M/(K+1))*K; // 반복되는 패턴 내 가장 큰 수의 갯수
    count+=M%(K+1); // (반복되는 패턴 내 가장 큰수의 갯수 + 반복되는 패턴 외 가장 큰수의 갯수) == 가장 큰수의 총 갯수
    result+=parseInt(index[0]*count); // 가장 큰 수를 모두 더한 값
    result+=parseInt(index[1]*(M-count)); // 두 번째로 큰 수를 모두 더한 값
    console.log(result);
}

main();

/*
B.js 설명에서 핵심 2번을 보면
"연산 과정에서 한 숫자만 연속으로 K번 사용가능하기 때문에
가장 큰 숫자 K번 사용 후에는 두 번째로 큰 숫자를 한 번만 사용하고
다시 가장 큰 숫자를 사용해도 된다는 것이다."

즉, 이 말은 연산과정에서 일정한 규칙의 패턴을 보인다는 의미인데
M==10,K==3, 가장 큰 두 수를 7,6 이라고 가정하고 예시를 보이겠다.

ex) (7 7 7 6) (7 7 7 6) (7 7)

위의 경우 (7 7 7 6)이 반복되는 것을 확인 할 수 있는데
이런 식으로 반복되는 갯수가 M/(K+1)개 임으로
이런 점을 이용하여 가장 큰 수가 연산에서 사용 될 갯수를 구할 수 있다.

위 코드의 경우 
가장 큰 수가 연산에서 사용될 갯수를 구하고 
두 번째 큰 수가 사용될 갯수도 구하여 한번에 연산을 해줌으로써
효율적이고 빠른 코드가 완성됐다.
*/

